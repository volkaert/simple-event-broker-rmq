# If stdlogs profile active: standard logs in the console. If jsonlogs profile active: JSON logs in the console and in rolling files
spring.profiles.active = stdlogs

# Server port, application name and instance id of this component/module
server.port = ${PORT:8083}
spring.application.name = ${COMPONENT_NAME:SubscriptionManager}
spring.application.instance_id = ${COMPONENT_INSTANCE_ID:${spring.application.name}-${CLUSTER_INDEX:0}}

# Telemetry
broker.telemetry.component-name = ${spring.application.name}
broker.telemetry.component-instance-id = ${spring.application.instance_id}

# Logging
logging.level.fr.volkaert = DEBUG
# For logging.file.name, you must provide only a filename and not a path+filename because of the config in logback-spring.xml
logging.file.name = ${broker.telemetry.component-instance-id}.log

# Credentials to call this component/module
broker.auth-client-id = some-client-id-for-subscription-manager
# the following secret has been encoded using https://www.devglan.com/online-tools/bcrypt-hash-generator
broker.auth-client-secret = $2a$04$lszAKgHIYO/sDBoeV1ehyOEBs3CMP/PNO6L9PBZ7eYRTMkIlyEXnC

# RabbitMQ
broker.rabbitmq-host = localhost
broker.rabbitmq-port = 5672
broker.rabbitmq-username = guest
broker.rabbitmq-password = guest

# Cluster size is the number of SubscriptionManager instances and Cluster index is the index of this
# SubscriptionManager instance within the cluster.
# Cluster index must  be ***UNIQUE*** within the cluster and must follow the sequence 0, 1... < Cluster size.
# The SubscriptionManager instance in charge of the management of an event is the instance that meets the
# criteria `broker.cluster-index == eventTypeCode.hashCode() % broker.cluster-size`.
# For a given event type, only one instance of SubscriptionManager will manage the events.
broker.cluster-size = ${CLUSTER_SIZE:1}
broker.cluster-index = ${CLUSTER_INDEX:0}

# URL and credentials to call the CatalogAdapter
broker.catalog-adapter-url = http://localhost:8085
#broker.catalog-adapter-url = lb://CatalogAdapter
broker.auth-client-id-for-catalog-adapter = some-client-id-for-catalog
broker.auth-client-secret-for-catalog-adapter = some-client-secret-for-catalog

# URL and credentials to call the Subscription Adapter
broker.subscription-adapter-url = http://localhost:8084
#broker.subscription-adapter-url = lb://SubscriptionAdapter
broker.auth-client-id-for-subscription-adapter = some-client-id-for-subscription-adapter
broker.auth-client-secret-for-subscription-adapter = some-client-secret-for-subscription-adapter

# Timeouts to connect and read the webhooks
broker.connect-timeout-in-seconds-for-subscription-adapter = 2
# Pay attention: the broker.read-timeout-in-seconds-for-subscription-adapter must LONGER than the broker.read-timeout-in-seconds-for-webhooks of the Subscription Adapter module
broker.read-timeout-in-seconds-for-subscription-adapter = 35

# Time to live for webhook errors
broker.default-time-to-live-in-seconds-for-webhook-connection-error = 864000
broker.default-time-to-live-in-seconds-for-webhook-read-timeout-error = 864000
broker.default-time-to-live-in-seconds-for-webhook-server5xx-error = 60
broker.default-time-to-live-in-seconds-for-webhook-client4xx-error = 60
broker.default-time-to-live-in-seconds-for-webhook-auth401or403-error = 60

# Time to live for DeadLetterQueues
# TTL set during queue declaration so cannot be changed afterwards
broker.time-to-live-in-seconds-for-dead-letter-queues = 86400
# TTL set at the message level so can be changed independently of the timeToLiveInSecondsForDeadLetterQueues
broker.time-to-live-in-seconds-for-dead-letter-messages = 86400

# Is event processing active ? Should be true on the primary datacenter and false on the backup datacenter (to avoid duplicate deliveries)
broker.event-processing-active = true

# Eureka Service Discovery
eureka.client.enabled = false
eureka.client.serviceUrl.defaultZone = http://localhost:8761/eureka/
#eureka.client.healthcheck.enabled = true
eureka.client.registryFetchIntervalSeconds = 10
eureka.client.initialInstanceInfoReplicationIntervalSeconds = 30
eureka.client.instanceInfoReplicationIntervalSeconds = 10
eureka.instance.instance-id = ${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id}
eureka.instance.leaseRenewalIntervalInSeconds = 5
eureka.instance.leaseExpirationDurationInSeconds = 10
spring.cloud.loadbalancer.ribbon.enabled = false

# Actuator endpoints (including liveness et readiness probes)
management.endpoints.web.exposure.include = *
management.endpoint.health.show-details = always
management.endpoint.health.show-components = always
#management.health.probes.enabled = true
#management.endpoint.health.group.liveness.include = livenessState,subscriptionManagerLiveness
#management.endpoint.health.group.readiness.include = readinessState,subscriptionManagerReadiness
#management.endpoint.health.roles = PROBES

# Graceful Shutdown (requires Spring Boot >= 2.3.x)
server.shutdown = graceful
spring.lifecycle.timeout-per-shutdown-phase = 5s

